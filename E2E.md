# Log-Sender End-to-End Process Flow and Testing Guide

## Table of Contents
1. [Overview](#overview)
2. [Process Flow](#process-flow)
3. [Key Management and Authentication](#key-management-and-authentication)
4. [BATS Testing Strategy](#bats-testing-strategy)
5. [Common Issues and Debugging](#common-issues-and-debugging)
6. [Best Practices](#best-practices)

## Overview

The `log-sender` application is a crucial component in the Holochain ecosystem that collects log entries from JSONL files and securely transmits them to a centralized `log-collector` service. This guide explains how it works and how to test it effectively.

**Key Responsibilities:**
- Read log files in JSONL format
- Generate cryptographic keys for device identity
- Register with log-collector service
- Sign and transmit log data securely
- Handle database size reporting

## Process Flow

### 1. Initialization Phase

The process begins when you run `log-sender init`:

```bash
log-sender init \
  --config-file /etc/log-sender/config.json \
  --endpoint http://log-collector:8787 \
  --unyt-pub-key uhCAkjC1PlxEz1LTEPytaNL10L9oy2kixwAABEjRWeKvN7xIAAAAB \
  --report-interval-seconds 60 \
  --report-path /data/logs \
  --conductor-config-path /path/to/conductor-config.toml
```

**What happens internally:**
1. **Parse Parameters**: Validates endpoint URL and unyt public key format
2. **Generate RSA Keypair**: Creates 2048-bit RSA keys for device authentication
3. **Create Config File**: Prepares configuration with generated keys
4. **Health Check**: Verifies log-collector service is reachable
5. **Drone Registration**: Registers with log-collector using generated keys
6. **Store Config**: Persists configuration with assigned drone_id

### 2. Service Operation Phase

When you run `log-sender service`:

```bash
log-sender service --config-file /etc/log-sender/config.json
```

**Operational loop:**
1. **Load Configuration**: Reads drone_id, keys, and settings
2. **Check Health**: Verifies log-collector connectivity
3. **Read Log Files**: Scans for new `.jsonl` files in specified paths
4. **Parse Entries**: Processes JSON objects with required "k" and "t" fields
5. **Sign Data**: Cryptographically signs log data with private key
6. **Submit Metrics**: Transmits signed data to `/metrics` endpoint
7. **Wait/Sleep**: Pauses for configured interval before next cycle

### 3. Log Format Requirements

Logs must follow the JSONL format:

```json
{"k":"start","t":"1758571617392359","namespace":"my-app","status":"initialized"}
{"k":"fetchedOps","t":"1758571617392360","count":150,"latency":42}
{"k":"custom_event","t":"1758571617392361","user_id":"abc123","action":"login"}
```

**Required fields:**
- `k` (kind): Log type identifier (Holochain uses "start", "fetchedOps")
- `t` (timestamp): Microsecond timestamp as string (`Date.now() * 1000`)

**Additional fields:** Any additional properties are allowed and preserved.

## Key Management and Authentication

### Key Types and Roles

1. **Unyt Public Key** (`unyt-pub-key`)
   - **Source**: Holochain agent key (uhCAk... format)
   - **Purpose**: Identifies the Holochain agent/dna
   - **Format**: Base64-encoded Holochain key

2. **Drone Public Key** (`dronePubKey`)
   - **Source**: Generated by log-sender during init
   - **Purpose**: Device identity for authentication
   - **Format**: Base64-encoded SPKI DER RSA public key

3. **Drone Secret Key** (`droneSecKey`)
   - **Source**: Generated alongside dronePubKey
   - **Purpose**: Signs registration and log submissions
   - **Format**: Base64-encoded PKCS8 DER RSA private key

### Registration Process

The `log-sender init` command performs device registration:

```rust
// Internal process (simplified)
let registration_payload = {
    "dronePubKey": "<base64 SPKI DER>",
    "unytPubKey": "<holochain key>",
    "droneSignature": "<RSA-PSS signature>",
    "signatureTimestamp": "<milliseconds>"
};
```

**What gets signed:**
The drone secret key signs this JSON payload:
```json
{"dronePubKey":"...","unytPubKey":"...","timestamp":1234567890}
```

### Log Submission Process

Each log submission includes:
- **Identities**: dronePubKey, unytPubKey, signingPubKey
- **Data**: Timestamp, metrics, proofs
- **Signature**: RSA-PSS signature of the payload
- **Verification**: Server validates signature using registered public key

## BATS Testing Strategy

### Test Philosophy

Focus on **user experience testing** rather than **API implementation testing**:

✅ **Do test:**
- Complete log-sender initialization workflow
- Service operation with real log files
- Database verification after processing
- Configuration file validation
- End-to-end data flow

❌ **Don't test:**
- Direct API calls to log-collector
- Internal crypto implementation details
- Mock registration endpoints

### Test Structure

#### 1. Setup Phase
```bash
# Each test should setup fresh environment
TEST_LOG_DIR="/data/logs/test_$(date +%s)"
docker compose exec -T -u nonroot edgenode-test rm -f /etc/log-sender/config.json
docker compose exec -T -u nonroot edgenode-test mkdir -p "$TEST_LOG_DIR"
```

#### 2. Test Data Creation
```bash
# Create realistic JSONL test data
local current_time=$(($(date +%s) * 1000000))
cat > /tmp/test_logs.jsonl <<EOF
{"k":"metric","t":"$current_time","value":100,"source":"test"}
{"k":"metric","t":"$((current_time + 1000000))","value":200,"source":"test"}
EOF
```

#### 3. Initialization Testing
```bash
# Test the actual log-sender command
run docker compose exec -T -u nonroot edgenode-test log-sender init \
    --config-file /etc/log-sender/config.json \
    --endpoint "$LOG_COLLECTOR_URL" \
    --unyt-pub-key "$UNYT_PUB_KEY" \
    --report-interval-seconds 2
assert_success
```

#### 4. Registration Verification
```bash
# Verify config contains registration data
verify_log_sender_registration "/etc/log-sender/config.json"
```

#### 5. Service Testing
```bash
# Run service and capture results
run docker compose exec -T -u nonroot -e RUST_LOG=info edgenode-test \
    timeout 15 log-sender service \
    --config-file /etc/log-sender/config.json \
    --report-path "$TEST_LOG_DIR"
```

#### 6. Database Verification
```bash
# Check database for stored data
local before_metrics=$(docker compose exec -T log-collector npx --yes wrangler d1 execute log-collector-db \
    --command="SELECT COUNT(*) as total FROM metrics;" | grep -o '[0-9]*' | head -1)
```

### Helper Functions

#### Registration Verification
```bash
verify_log_sender_registration() {
    local config_file="$1"
    
    # Check RSA public key format
    if docker compose exec -T -u nonroot edgenode-test jq -r '.drone_pub_key' "$config_file" | grep -q "MIIB"; then
        echo "✅ Config contains valid RSA drone public key"
    else
        echo "❌ Config missing or invalid drone public key"
        return 1
    fi
    
    # Check Holochain public key format
    if docker compose exec -T -u nonroot edgenode-test jq -r '.unyt_pub_key' "$config_file" | grep -q "uhCAk"; then
        echo "✅ Config contains valid Holochain unyt public key"
    else
        echo "❌ Config missing or invalid unyt public key"
        return 1
    fi
    
    # Check drone_id (indicates successful registration)
    if docker compose exec -T -u nonroot edgenode-test jq -r '.drone_id' "$config_file" | grep -q "[0-9]"; then
        echo "✅ Config contains drone ID (registration successful)"
        return 0
    else
        echo "⚠️  Config missing drone ID (registration may not have completed)"
        return 1
    fi
}
```

#### Database Content Display
```bash
display_database_contents() {
    echo "=== DATABASE STATE ==="
    
    # Check metrics table
    echo "Metrics count:"
    docker compose exec -T log-collector npx --yes wrangler d1 execute log-collector-db \
        --command="SELECT COUNT(*) as total FROM metrics;" | grep -o '[0-9]*' | head -1
    
    # Check drone registrations
    echo "Drone registrations:"
    docker compose exec -T log-collector npx --yes wrangler d1 execute log-collector-db \
        --command="SELECT COUNT(*) as total FROM drone_registrations;" | grep -o '[0-9]*' | head -1
}
```

## Common Issues and Debugging

### 1. Key Format Mismatch

**Problem**: `log-sender` produces PEM format, but `log-collector` expects pure SPKI DER

**Symptoms**:
- Registration fails with "Invalid device key" error
- Key validation errors in log-collector

**Solution**: Fixed in `src/crypto.rs`
```rust
// Changed from PEM to SPKI DER
pub fn encode(&self) -> Result<String> {
    use rsa::pkcs8::EncodePublicKey;
    Ok(BASE64_STANDARD.encode(
        self.0
            .to_public_key_der()  // Changed from to_public_key_pem()
            .map_err(std::io::Error::other)?
            .as_bytes(),
    ))
}
```

### 2. Timestamp Format Issues

**Problem**: Log timestamps must be in microseconds

**Symptoms**:
- No logs appear in database
- Timestamp validation errors

**Solution**: Ensure timestamp format
```bash
# Correct: microseconds
local current_time=$(($(date +%s) * 1000000))

# Incorrect: milliseconds  
local current_time=$(date +%s)000
```

### 3. JSONL Format Validation

**Problem**: Invalid JSON or missing required fields

**Symptoms**:
- No logs processed
- Parser errors

**Solution**: Validate log format
```bash
# Check file exists and is readable
assert_file_exists "$TEST_LOG_DIR/test.jsonl"

# Verify JSONL format
run docker compose exec -T -u nonroot edgenode-test jq -c '.' "$TEST_LOG_DIR/test.jsonl"
assert_success
```

### 4. Network Connectivity Issues

**Problem**: Cannot reach log-collector service

**Symptoms**:
- Connection refused errors
- Health check failures

**Solution**: Verify network and service
```bash
# Check log-collector is running
run curl -s "http://localhost:8787/"
assert_output --partial "log-collector"

# Check configuration endpoints
run docker compose exec -T -u nonroot edgenode-test curl -s "http://log-collector:8787/health"
assert_success
```

## Best Practices

### 1. Test Data Management
- Use unique test namespaces to avoid conflicts
- Clean up test data after each test
- Use realistic timestamp formats
- Include all required log fields

### 2. Configuration Testing
- Test different config file paths
- Verify all config fields are populated
- Test error handling for invalid configs
- Validate key format requirements

### 3. Service Testing
- Test with various log file sizes
- Test with empty directories
- Test with corrupted log files
- Test service startup/shutdown behavior

### 4. Database Integration
- Always verify data reaches database
- Check for proper timestamp ordering
- Validate key associations
- Test concurrent registration scenarios

### 5. Error Handling
- Test with invalid endpoints
- Test with malformed logs
- Test network interruption scenarios
- Test certificate validation (if HTTPS)

### 6. Performance Considerations
- Test with large log files
- Test with high-frequency log generation
- Test service under load
- Monitor memory usage during processing

## Testing Checklist

Before running tests, ensure:

- [ ] Log-collector service is running and accessible
- [ ] Database is initialized with correct schema
- [ ] Test environment variables are set
- [ ] Network connectivity between test containers
- [ ] Test data directories are writable
- [ ] Cleanup procedures are in place
- [ ] Test timeout values are appropriate
- [ ] Debug logging is available when needed

## Summary

The log-sender application follows a clear process flow from initialization through service operation. Effective testing focuses on the complete user experience rather than implementation details. Key areas to validate include:

1. **Key Generation and Format**: RSA keypair creation and proper encoding
2. **Registration Process**: Successful drone registration with log-collector
3. **Log Processing**: Accurate reading and submission of JSONL files
4. **Database Integration**: Proper storage and retrieval of log data
5. **Error Handling**: Graceful handling of various failure scenarios

By following this guide and using the BATS testing framework, you can ensure robust end-to-end testing of the log-sender system.